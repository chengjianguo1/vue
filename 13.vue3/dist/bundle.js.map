{"version":3,"file":"bundle.js","sources":["../src/reactivity/effect.ts","../src/shared/index.ts","../src/reactivity/baseHandlers.ts","../src/reactivity/reactive.ts"],"sourcesContent":["export const effect = (fn, options = {}) => {\n    // 需要让传递来的fn 变成响应式的effect，数据有变化 这个fn就能重新执行\n    const effect = createReactiveEffect(fn); //fn用户传递的函数\n    effect();\n}\n\n// effect 应该和数据关联起来\n\n\nexport const effectStack = [];\nfunction createReactiveEffect(fn) {\n    const effect =  function reactiveEffect() {\n\n        effectStack.push(effect);\n\n        fn(); // 让函数执行\n    }\n    return effect;\n}","export const isObject = (val:unknown):val is Object => typeof val == 'object' && val !== null;","// proxy 和 reflect 连用 （reflect 以后会取代掉 object上一系列法 ）\n\nimport { effectStack } from \"./effect\";\nexport const mutableHandlers = {\n    // 目标原对象 属性 代理后的对象\n    get(target, key, recevier) {  // 内置的 proxy中get和set参数是固定的\n\n        console.log('get')\n\n        return Reflect.get(target, key, recevier); // taget[key]\n    }, // 当取值的时候 应该将effect 存储起来\n    set(target, key, value, recevier) {\n\n        console.log('set')\n        let result = Reflect.set(target, key, value, recevier);\n        effectStack.forEach(effect=>effect());\n        return result\n    } // 当设置值的时候 应该通知对应的effect来更新\n}\n\n// 默认加载页面时 会先调用一次effect，此时effect方法中的数据会进行取值操作 -》 get方法\n//                让对应的属性保存当前的effect  =>  某个对象中 name属性  对应的effect有几个\n\n// 某个对象中 name属性 变化了 ， 需要找到对应的effect列表让他依次执行\n","import { isObject } from \"../shared\";\nimport { mutableHandlers } from \"./baseHandlers\";\n\nexport const reactive = (target: object) => {\n    // 你给我一个对象 我需要让这个对象变成响应式对象 \n    // 在vue2.0的时候 defineProprety直接循环对象中的每一个属性， 无法对不存在的属性做处理.递归处理多级对象\n    // vue3.0 没有循环 对原对象进行代理,vue3不存在的属性也可以监控到,vue3 没有以上来就递归\n    return createReactiveObject(target, mutableHandlers); // 高阶函数，可以根据不同的参数实现不同的功能\n}\nconst reactiveMap = new WeakMap();// 映射表中的key必须是对象，而且不会有内存泄漏的问题\nfunction createReactiveObject(target, baseHandler) {\n    // 如果这个target 是一个对象\n    if (!isObject(target)) { // 不是对象直接返回即可\n        return target;\n    }\n    // 如果对象已经被代理过了，就不要再次代理了\n    let existProxy = reactiveMap.get(target);\n    if (existProxy) {\n        return existProxy; // 返回上一次的代理\n    }\n    const proxy = new Proxy(target, baseHandler); // reactive核心功能就是 proxy\n    reactiveMap.set(target, proxy);  // {需要代理的对象：代理后的值}\n    return proxy;\n}"],"names":[],"mappings":";;;;;;QAAa,MAAM,GAAG,UAAC,EAAE,EAAE,OAAY;;QAEnC,IAAM,MAAM,GAAG,oBAAoB,CAAC,EAAE,CAAC,CAAC;QACxC,MAAM,EAAE,CAAC;IACb,EAAC;IAED;IAGO,IAAM,WAAW,GAAG,EAAE,CAAC;IAC9B,SAAS,oBAAoB,CAAC,EAAE;QAC5B,IAAM,MAAM,GAAI,SAAS,cAAc;YAEnC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAEzB,EAAE,EAAE,CAAC;SACR,CAAA;QACD,OAAO,MAAM,CAAC;IAClB;;IClBO,IAAM,QAAQ,GAAG,UAAC,GAAW,IAAmB,OAAA,OAAO,GAAG,IAAI,QAAQ,IAAI,GAAG,KAAK,IAAI,GAAA;;ICA7F;IAGO,IAAM,eAAe,GAAG;;QAE3B,GAAG,YAAC,MAAM,EAAE,GAAG,EAAE,QAAQ;YAErB,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAA;YAElB,OAAO,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,QAAQ,CAAC,CAAC;SAC7C;QACD,GAAG,YAAC,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,QAAQ;YAE5B,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAA;YAClB,IAAI,MAAM,GAAG,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;YACvD,WAAW,CAAC,OAAO,CAAC,UAAA,MAAM,IAAE,OAAA,MAAM,EAAE,GAAA,CAAC,CAAC;YACtC,OAAO,MAAM,CAAA;SAChB;KACJ,CAAA;IAED;IACA;IAEA;;QCpBa,QAAQ,GAAG,UAAC,MAAc;;;;QAInC,OAAO,oBAAoB,CAAC,MAAM,EAAE,eAAe,CAAC,CAAC;IACzD,EAAC;IACD,IAAM,WAAW,GAAG,IAAI,OAAO,EAAE,CAAC;IAClC,SAAS,oBAAoB,CAAC,MAAM,EAAE,WAAW;;QAE7C,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE;YACnB,OAAO,MAAM,CAAC;SACjB;;QAED,IAAI,UAAU,GAAG,WAAW,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QACzC,IAAI,UAAU,EAAE;YACZ,OAAO,UAAU,CAAC;SACrB;QACD,IAAM,KAAK,GAAG,IAAI,KAAK,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;QAC7C,WAAW,CAAC,GAAG,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;QAC/B,OAAO,KAAK,CAAC;IACjB;;;;;;;;;;;"}