{"version":3,"file":"bundle.js","sources":["../src/shared/index.ts","../src/reactivity/effect.ts","../src/reactivity/baseHandlers.ts","../src/reactivity/reactive.ts"],"sourcesContent":["export const isObject = (val:unknown):val is Object => typeof val == 'object' && val !== null;\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\nexport const hasOwn = (target,key) => hasOwnProperty.call(target,key);\n\n\nexport const isArray = (target)=> Array.isArray(target);\n\n\nexport const hasChange = (oldVal,newVal)=>oldVal !== newVal","import { isArray } from \"../shared\";\n\nexport const effect = (fn, options = {}) => {\n    // 需要让传递来的fn 变成响应式的effect，数据有变化 这个fn就能重新执行\n    const effect = createReactiveEffect(fn); //fn用户传递的函数\n    effect();\n}\n// effect 应该和数据关联起来\n// effect1(()=>{\n//     state.name\n//     effect2(()=>{\n//         state.age\n//     })\n//     state.address\n// })\n\n// 默认先调用effect1 内部对state.name取值 ， 把name属性和 activeEffect(effect1) 关联起来\n// 调用effect2 内部对state.age取值， 把age 和 activeEffect(effect2) 关联起来\n// effect2 执行完毕 activeEffect 指向effect1\n// state.address 再次取值 此时关联到了 effect1\n\n// 数据变化effect就会重新执行\n// effect(()=>{\n//     state.name++;\n// })\n\nexport let effectStack = []; // 这个栈为了保证当前effect 和属性能对应上\nexport let activeEffect = null;\nlet id = 0;\nfunction createReactiveEffect(fn) {\n    const effect = function reactiveEffect() {\n        if (!effectStack.includes(effect)) {\n            try {\n                effectStack.push(effect);\n                activeEffect = effect;\n                return fn(); // 让函数执行, 会执行取值逻辑. 在取值逻辑中可以和effect做关联\n            } finally {\n                effectStack.pop();\n                activeEffect = effectStack[effectStack.length - 1]\n            }\n        }\n\n    }\n    effect.id = id++;\n    return effect;\n}\n// 某个对象中的  某个属性 依赖了 哪些effect\n\n// {对象:{name:[]}}  // weakMap set\nconst targetMap = new WeakMap;\n// 建立属性 和 effect之间的关联\nexport function track(target, key) {\n    if (activeEffect == undefined) {\n        return;\n    }\n    let depsMap = targetMap.get(target);\n    if (!depsMap) { // 枚举\n        targetMap.set(target, (depsMap = new Map())); // weakMap 为了解决内存泄漏\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n        depsMap.set(key, (dep = new Set()));\n    }\n    if (!dep.has(activeEffect)) {\n        dep.add(activeEffect);\n    }\n}\n\nconst run = (effects) => {\n    if (effects) effects.forEach(effect => effect());\n}\nexport function trigger(target, type, key,value) {\n    const depsMap = targetMap.get(target);\n    if (!depsMap) {// 属性变化了 但是没有依赖 直接跳过即可\n        return;\n    }\n    // 修改\n    if(key == 'length' && isArray(target)){\n        depsMap.forEach((dep,key)=>{ // 只要改了length就触发\n            // 如果改变了 数组长度 那么一定要更新  改变的长度 小于取值的长度\n            // 这里是2 收集的   2     1\n\n\n            // key => {map中的key}  =》 {name:set:[]}\n            // 如果你修改的是长度 正好内部也对长度进行了收集 长度也要触发\n            if(key == 'length' || key >= value){\n                run(dep)\n            }\n        });\n    }else{\n        if (key !== undefined) { // 如果有收集过就触发\n            let effects = depsMap.get(key);\n            run(effects)\n        }\n    \n        switch (type) {\n            case 'add': // 添加属性 需要触发length\n                if (isArray(target)) {\n                    if (parseInt(key) == key) {\n                        run(depsMap.get('length')); // 打补丁 ，不更新就手动触发吧\n                    }\n                }\n                break;\n    \n            default:\n                break;\n        }\n    }\n}\n\n// 下次课 vue3计算属性 ref、toRefs , 异步更新原理 虚拟dom原理 vue3 diff算法\n// vite 原理\n\n// vue3 实战写一个项目 vue3 + ts 用法\n// ts 实战 手写个axios库\n\n// 周日的话咱们开node （2,4） 补课\n","// proxy 和 reflect 连用 （reflect 以后会取代掉 object上一系列法 ）\n\nimport { reactive } from \"./reactive\";\nimport { hasChange, hasOwn, isArray, isObject } from \"../shared\";\nimport { activeEffect, effectStack } from \"./effect\";\nimport { track } from \"./effect\";\nimport { trigger } from \"./effect\";\nexport const mutableHandlers = {\n    // 目标原对象 属性 代理后的对象\n    get(target, key, recevier) {  // 内置的 proxy中get和set参数是固定的\n        let res = Reflect.get(target, key, recevier);\n\n        if(typeof key == 'symbol'){ // 如果是内置的symbol 就排除掉依赖收集\n            return res;\n        }\n        track(target,key); // 属性 和 effect之间做一个关联\n       \n        return  isObject(res) ? reactive(res) : res// taget[key]\n    }, // 当取值的时候 应该将effect 存储起来\n    set(target, key, value, recevier) {\n        const oldValue = target[key]; // 上一次的结果\n\n\n        // 如果是数组 就比较当前新增的属性 是否比长度大，大的话就是以前没有新增的\n\n        const hadKey = isArray(target) && (parseInt(key,10) == key)? Number(key) < target.length: hasOwn(target,key);\n\n        let result = Reflect.set(target, key, value, recevier);\n        // 调用push方法 会先进行添加属性 在去更新长度（这次长度更新是没有意义的）\n        if(!hadKey){\n            trigger(target,'add',key,value); // 触发新增操作\n        }else if(hasChange(oldValue,value)){\n            trigger(target,'set',key,value);\n        }\n        // 设置一般分为两种一种是添加新的属性,还有种是修改属性\n        return result\n    } // 当设置值的时候 应该通知对应的effect来更新\n}\n\n// 默认加载页面时 会先调用一次effect，此时effect方法中的数据会进行取值操作 -》 get方法\n//                让对应的属性保存当前的effect  =>  某个对象中 name属性  对应的effect有几个\n\n// 某个对象中 name属性 变化了 ， 需要找到对应的effect列表让他依次执行\n","import { isObject } from \"../shared\";\nimport { mutableHandlers } from \"./baseHandlers\";\n\nexport const reactive = (target: object) => {\n    // 你给我一个对象 我需要让这个对象变成响应式对象 \n    // 在vue2.0的时候 defineProprety直接循环对象中的每一个属性， 无法对不存在的属性做处理.递归处理多级对象\n    // vue3.0 没有循环 对原对象进行代理,vue3不存在的属性也可以监控到,vue3 没有以上来就递归\n    return createReactiveObject(target, mutableHandlers); // 高阶函数，可以根据不同的参数实现不同的功能\n}\nconst reactiveMap = new WeakMap();// 映射表中的key必须是对象，而且不会有内存泄漏的问题\nfunction createReactiveObject(target, baseHandler) {\n    // 如果这个target 是一个对象\n    if (!isObject(target)) { // 不是对象直接返回即可\n        return target;\n    }\n    // 如果对象已经被代理过了，就不要再次代理了\n    let existProxy = reactiveMap.get(target);\n    if (existProxy) {\n        return existProxy; // 返回上一次的代理\n    }\n    const proxy = new Proxy(target, baseHandler); // reactive核心功能就是 proxy\n    reactiveMap.set(target, proxy);  // {需要代理的对象：代理后的值}\n    return proxy;\n}"],"names":[],"mappings":"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"}