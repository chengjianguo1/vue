{"version":3,"file":"bundle.js","sources":["../src/shared/index.ts","../src/reactivity/effect.ts","../src/reactivity/baseHandlers.ts","../src/reactivity/reactive.ts","../src/reactivity/computed.ts","../src/reactivity/ref.ts"],"sourcesContent":["export const isObject = (val:unknown):val is Object => typeof val == 'object' && val !== null;\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\nexport const hasOwn = (target,key) => hasOwnProperty.call(target,key);\n\n\nexport const isArray = (target)=> Array.isArray(target);\n\n\nexport const hasChange = (oldVal,newVal)=>oldVal !== newVal;\n\n\nexport const isFunction = (val) => typeof val == 'function'","import { isArray } from \"../shared\";\n\nexport const effect = (fn, options: any = {}) => {\n    // 需要让传递来的fn 变成响应式的effect，数据有变化 这个fn就能重新执行\n    const effect = createReactiveEffect(fn,options); //fn用户传递的函数\n\n    if (!options.lazy) {\n        effect();\n    }\n\n    return effect\n}\n\n\n// effect 应该和数据关联起来\n// effect1(()=>{\n//     state.name\n//     effect2(()=>{\n//         state.age\n//     })\n//     state.address\n// })\n\n// 默认先调用effect1 内部对state.name取值 ， 把name属性和 activeEffect(effect1) 关联起来\n// 调用effect2 内部对state.age取值， 把age 和 activeEffect(effect2) 关联起来\n// effect2 执行完毕 activeEffect 指向effect1\n// state.address 再次取值 此时关联到了 effect1\n\n// 数据变化effect就会重新执行\n// effect(()=>{\n//     state.name++;\n// })\n\nexport let effectStack = []; // 这个栈为了保证当前effect 和属性能对应上\nexport let activeEffect = null;\nlet id = 0;\nfunction createReactiveEffect(fn,options) {\n    const effect = function reactiveEffect() {\n        if (!effectStack.includes(effect)) {\n            try {\n                effectStack.push(effect);\n                activeEffect = effect;\n                return fn(); // 让函数执行, 会执行取值逻辑. 在取值逻辑中可以和effect做关联\n            } finally {\n                effectStack.pop();\n                activeEffect = effectStack[effectStack.length - 1]\n            }\n        }\n\n    }\n    effect.id = id++;\n    effect.options = options;\n    return effect;\n}\n// 某个对象中的  某个属性 依赖了 哪些effect\n\n// {对象:{name:[]}}  // weakMap set\nconst targetMap = new WeakMap;\n// 建立属性 和 effect之间的关联\nexport function track(target, key) {\n    if (activeEffect == undefined) {\n        return;\n    }\n    let depsMap = targetMap.get(target);\n    if (!depsMap) { // 枚举\n        targetMap.set(target, (depsMap = new Map())); // weakMap 为了解决内存泄漏\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n        depsMap.set(key, (dep = new Set()));\n    }\n    if (!dep.has(activeEffect)) {\n        dep.add(activeEffect);\n    }\n}\n\nconst run = (effects) => {\n    if (effects) effects.forEach(effect =>{ // effect 有两种 1.渲染 2.计算属性对应的effect\n        if(effect.options.scheduler){ // 计算属性 \n            effect.options.scheduler(effect);\n        }else{\n            effect();\n        }\n    });\n}\nexport function trigger(target, type, key, value?) {\n    const depsMap = targetMap.get(target);\n    if (!depsMap) {// 属性变化了 但是没有依赖 直接跳过即可\n        return;\n    }\n    // 修改\n    if (key == 'length' && isArray(target)) {\n        depsMap.forEach((dep, key) => { // 只要改了length就触发\n            // 如果改变了 数组长度 那么一定要更新  改变的长度 小于取值的长度\n            // 这里是2 收集的   2     1\n\n\n            // key => {map中的key}  =》 {name:set:[]}\n            // 如果你修改的是长度 正好内部也对长度进行了收集 长度也要触发\n            if (key == 'length' || key >= value) {\n                run(dep)\n            }\n        });\n    } else {\n        if (key !== undefined) { // 如果有收集过就触发\n            let effects = depsMap.get(key);\n            run(effects)\n        }\n\n        switch (type) {\n            case 'add': // 添加属性 需要触发length\n                if (isArray(target)) {\n                    if (parseInt(key) == key) {\n                        run(depsMap.get('length')); // 打补丁 ，不更新就手动触发吧\n                    }\n                }\n                break;\n            default:\n                break;\n        }\n    }\n}\n// 下次课 vue3计算属性 ref、toRefs , 异步更新原理 虚拟dom原理 vue3 diff算法\n// vite 原理\n// vue3 实战写一个项目 vue3 + ts 用法\n// ts 实战 手写个axios库\n// 周日的话咱们开node （2,4） 补课\n\n// node tcp eggjs 进程 单元测试\n","// proxy 和 reflect 连用 （reflect 以后会取代掉 object上一系列法 ）\n\nimport { reactive } from \"./reactive\";\nimport { hasChange, hasOwn, isArray, isObject } from \"../shared\";\nimport { activeEffect, effectStack } from \"./effect\";\nimport { track } from \"./effect\";\nimport { trigger } from \"./effect\";\nexport const mutableHandlers = {\n    // 目标原对象 属性 代理后的对象\n    get(target, key, recevier) {  // 内置的 proxy中get和set参数是固定的\n        let res = Reflect.get(target, key, recevier);\n\n        if(typeof key == 'symbol'){ // 如果是内置的symbol 就排除掉依赖收集\n            return res;\n        }\n        track(target,key); // 属性 和 effect之间做一个关联\n\n        if(res.__v_isRef){\n            return res.value;\n        }\n\n       \n        return  isObject(res) ? reactive(res) : res// taget[key]\n    }, // 当取值的时候 应该将effect 存储起来\n    set(target, key, value, recevier) {\n        const oldValue = target[key]; // 上一次的结果\n\n\n        // 如果是数组 就比较当前新增的属性 是否比长度大，大的话就是以前没有新增的\n\n        const hadKey = isArray(target) && (parseInt(key,10) == key)? Number(key) < target.length: hasOwn(target,key);\n\n        let result = Reflect.set(target, key, value, recevier);\n        // 调用push方法 会先进行添加属性 在去更新长度（这次长度更新是没有意义的）\n        if(!hadKey){\n            trigger(target,'add',key,value); // 触发新增操作\n        }else if(hasChange(oldValue,value)){\n            trigger(target,'set',key,value);\n        }\n        // 设置一般分为两种一种是添加新的属性,还有种是修改属性\n        return result\n    } // 当设置值的时候 应该通知对应的effect来更新\n}\n\n// 默认加载页面时 会先调用一次effect，此时effect方法中的数据会进行取值操作 -》 get方法\n//                让对应的属性保存当前的effect  =>  某个对象中 name属性  对应的effect有几个\n\n// 某个对象中 name属性 变化了 ， 需要找到对应的effect列表让他依次执行\n","import { isObject } from \"../shared\";\nimport { mutableHandlers } from \"./baseHandlers\";\n\nexport const reactive = (target: object) => {\n    // 你给我一个对象 我需要让这个对象变成响应式对象 \n    // 在vue2.0的时候 defineProprety直接循环对象中的每一个属性， 无法对不存在的属性做处理.递归处理多级对象\n    // vue3.0 没有循环 对原对象进行代理,vue3不存在的属性也可以监控到,vue3 没有以上来就递归\n    return createReactiveObject(target, mutableHandlers); // 高阶函数，可以根据不同的参数实现不同的功能\n}\nconst reactiveMap = new WeakMap();// 映射表中的key必须是对象，而且不会有内存泄漏的问题\nfunction createReactiveObject(target, baseHandler) {\n    // 如果这个target 是一个对象\n    if (!isObject(target)) { // 不是对象直接返回即可\n        return target;\n    }\n    // 如果对象已经被代理过了，就不要再次代理了\n    let existProxy = reactiveMap.get(target);\n    if (existProxy) {\n        return existProxy; // 返回上一次的代理\n    }\n    const proxy = new Proxy(target, baseHandler); // reactive核心功能就是 proxy\n    reactiveMap.set(target, proxy);  // {需要代理的对象：代理后的值}\n    return proxy;\n}","import { effect, track, trigger } from \"./effect\";\nimport { isFunction } from \"../shared\";\nclass ComputedRefImpl{\n    public effect;\n    public __v_isReadonly = true;\n    public readonly __v_isRef = true;\n    public _dirty = true;\n    private _value;\n    public setter;\n    constructor(getter, setter){\n        this.setter = setter;\n        // 默认getter执行的时候会依赖于一个effect （计算属性默认就是一个effect）\n        this.effect = effect(getter,{\n            lazy:true, // 标识默认的时候 不会执行\n            scheduler:()=>{ // 默认就算属性依赖的值变化会执行scheduler方法\n                this._dirty = true;// 依赖的值变化了 变成脏值\n                trigger(this,'set','value');\n            }\n        });\n    }\n    get value(){ // 类属性描述器\n        if(this._dirty){ // 缓存\n            this._value = this.effect();\n            track(this,'value'); // 取值时收集依赖 {this:{'value':[effect]}\n            this._dirty = false;\n        }\n        return this._value\n    }\n    set value(newValue){ // 自动去调用用户的set即可  myAge.value = xxx\n        this.setter(newValue)\n    }\n}\nexport function computed(getterOrOptions){\n    // 分别拿到get和set\n    let getter;\n    let setter;\n\n    if(isFunction(getterOrOptions)){\n        getter = getterOrOptions;\n        setter = ()=>{console.log('computed  not set value')}\n    }else{\n        getter = getterOrOptions.get;\n        setter = getterOrOptions.set;\n    }\n    return new ComputedRefImpl(getter,setter);\n}","import { reactive } from \"./reactive\";\nimport { hasChange, isArray, isObject } from \"../shared\";\nimport { track, trigger } from \"./effect\";\n\nconst convert = (val) => isObject(val)?reactive(val):val\nclass RefImpl {\n    public _rawValue;\n    public readonly __v_isRef =  true;;\n    public _value;\n    constructor(public rawValue) { // rawValue类型\n        this._rawValue = rawValue;\n        this._value = convert(rawValue)\n    }\n    get value(){ // 属性访问器 这里新增了value属性\n        track(this,'value'); // {this:{value:[effect]}}  depend\n        return this._value\n    }\n    set value(newValue){\n        if(hasChange(newValue,this._rawValue)){ // 如果值有变化再去触发更新，如果值没发生变化 就不要再次触发更新了\n            this._rawValue = newValue\n            this._value =  convert(newValue);\n            trigger(this,'set','value'); // notify\n        }\n    }\n}\nexport function ref(rawValue){\n    return new RefImpl(rawValue)\n}\n\nclass ObjectRefImpl{\n    constructor(public _object,public _key){\n    }\n\n    // 代理操作 vue2 this._data 代理到vm上一个意思\n    get value(){\n        return this._object[this._key]; // 读取的是原值 （原来的值都不是响应式 那不能是响应的）\n    }\n    set value(newValue){\n        this._object[this._key] = newValue\n    }\n}\nexport function toRefs(object){ // object可能是数组\n\n    const result = isArray(object)? new Array(object.length) : {}\n\n    for(let key in object){\n        result[key] = new ObjectRefImpl(object,key);\n    }\n\n    return result\n}\n\n"],"names":[],"mappings":"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"}